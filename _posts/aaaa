# 6장 작업 실행

어플리케이션이 해야 할 일을 작업이라는 단위로 분할하면 프로그램의 구조를 간결하게 잡을 수 있고, 트랜잭션의 범위를 지정함으로써 오류에 효과적으로 대응할 수 있고, 작업 실행 부분의 병렬성을 자연스럽게 극대화할 수 있다.

## 6.1 스레드에서 작업 실행

프로그램에서 일어나는 일을 작업이라는 단위로 재구성하고자 한다면 가장 먼저 해야할 일은 `작업의 범위`를 어디까지 할 것인지 정하는 일이다.
원론적으로 보자면 작업은 완전히 독립적인 동작을 말한다.

### 6.1.1 작업을 순차적으로 실행

```java
class SingleThreadWebServer {
    public static void main(String[] args) throws IOException {
        ServerSocket socket = new ServerSocket(80);
        while (true) {
            Socket connection = socekt.accept();
            handleRequest(connection);
        }
    }
}
```

기본 스레드는 네트웍 소켓 연결을 기다리고 있다가 클라이언트가 보내 온 요청을 처리하는 과정을 반복한다.

### 6.1.2 작업마다 스레드를 직접 생성

```java
class ThreadPerTaskWebServer {
    public static void main(String[] args) throws IOException {
        ServerSocket socket = new ServerSocket(80);
        while (true) {
            final Socket connection = socket.accept();
            Runnable task = new Runnable() {
                public void run() {
                    handleRequest(connection);
                }
            }
            new Thread(task).start();
        }
    }
}
```

세가지 결과
* 다음 클라이언트의 접속을 기다리는 부분으로 빨리 넘거갈 수 있다.
* 동시에 여러 작업을 병렬로 처리할 수 있기 때문에 두 개 이상의 요청을 받아 동시에 처리할 수 있다.
* 여러 클라이언트가 접속하는 경우 동시에 동작할 가능성이 매우 높기 때문에 스레드 안전성을 확보해야 한다.

### 6.1.3 스레드를 많이 생성할 때의 문제점

* 스레드 라이프 사이클 문제
스레드를 생성하고 제거하는 작업에도 자원이 소모된다.

* 자원 낭비
실행 중인 스레드는 시스템의 자원, 큭히 메모리를 소모한다. 
하드웨어에 실제로 장착되어 있는 프로세서보다 많은 수의 스레드가 만들어져 동작 중이라면, 실제로는 대부분의 스레드가 대기(idle) 상태에 머무른다.

* 안정성 문제
모든 시스템에는 생성할 수 있는 스레드의 개수가 제한되어 있다.
JVM을 실행할 때 지정하는 인자나 Thread 클래스에 필요한 스택의 크기에 따라서 달라지기도 한다.
만약 제한된 양을 모두 사용하고 나면 아마도 `OutOfMemoryError`가 발생한다.

```
32비트 시스템이라면 가장 큰 제약 요소는 바로 스레드 스택에 적용되는 주소 공간이다.
자바 코드와 네이티브 코드를 실행할 수 있도록 모든 스레드는 두 개의 스택을 갖는다.
일반적인 JVM의 기본값으로 보면 두 개의 스택을 더한 용량이 대략 0.5MB 정도 된다.
예를 들어, 스레드별 스택 크기를 2^32로 나눈 값으로 설정하면, 수천 개나 수만 개의 스레드를 사용할 수 있다.
```

일정한 수준까지는 스레드를 추가로 만들어 사용해서 성능상의 이점을 얻을 수 있지만, 특정 수준을 넘어간다면 성능이 떨어지게 마련이다.

## 6.2 Executor 프레임웍

Executor는 작업 등록과 작업 실행을 분리하는 표준적인 방법이다.
각 작업은 Runnable의 형태로 정의한다.

Executor 인터페이스를 구현한 클래스는 
* 작업의 라이프 사이클을 관리하는 기능
* 몇 가지 통계 값을 뽑아내는 기능
* 애클리케이션에서 작업 실행 과정을 관리하고 모니터링하기 위한 기능

Executor의 구조는 프로듀서-컨슈머 패턴에 기반하고 있다.

### 6.2.1 예제: Executor를 사용한 웹서버

### 6.2.2 실행 정책

작업을 등록하는 부분과 실행하는 부분을 서로 분리시켜두면 특정 작업을 실행하고자 할 때 코드를 많이 변경하거나 기타 여러 가지 어려운 상황에 맞닥뜨리지 않으면서도 실행 정책을 언제든지 변경할 수 있다는 장점이 있다.

### 6.2.3 스레드 풀

스레드 풀은 이름 그대로 작업을 처리할 수 있는 동일한 형태의 스레드를 풀의 형태로 관리한다.
일반적으로 스레드 풀은 풀 내부의 스레드로 처리할 작업을 쌓아둬야 하기 때문에 작업 큐와 굉장히 밀접한 관련이 있다.

스레드 풀을 사용하면 매번 스레드를 생성하는 대신 이전에 사용했던 스레드를 `재사용`하기 때문에 스레드를 계속해서 생성할 필요가 없다.

#### Executor 클래스

* newFixedThreadPool
처리할 작업이 등록되면 그에 따라 실제 작업할 스레드를 하나씩 생성한다.
생성할 수 있는 `스레드의 최대 개수는 제한`되어 있으며 제한된 개수까지 스레드를 생성하고 나면 더 이상 생성하지 않고 스레드 수를 유지한다.

* newCachedThreadPool
현재 풀에 갖고 있는 스레드의 수가 처리할 작업의 수보다 많아서 쉬는 스레드가 많이 발생할 때 쉬는 스레드를 종료
처리할 작업의 수가 많아지면 필요한 만큼 스레드를 새로 생성
`스레드의 수에는 제한을 두지 않는다.`

* newSingleThreaExecutor
단일 스레드로 동작하는 Executor 로서 작업을 처리하는 스레드가 단 하나뿐이다.

* newScheduledThreaPool
일정 시간 이후에 실행하거나 주기적으로 작업을 실행할 수 있다.
스레드의 수가 고정되어 있는 형태의 Executor.Timer 클래스의 기능과 유사하다.

newFixedThreadPool과 newCahchedThreadPool 팩토리 메소드는 일반화된 형태로 구현되어 있는 ThreadPoolExecutor 클래스의 인스턴스를 생성한다.

### 6.2.4 Executor 동작 주기

ExecutorService가 갖고 있는 동작 주기에는 실행 중(running), 종료 중(shutting down), 종료(terminated)의 세가지 상태가 있다.
* **shutdown** 메소드를 실행하면 `안전한 종료 절차`를 진행하며 종료 중 상태로 들어간다.
이 상태에서는 새로운 작업을 등록 받지 않으며, 이전에 등록되어 있던 작업까지는 모두 끝마칠수 있다.
* **shotdownNow** 메소드를 실행하면 `강제 종료 절차`를 진행한다.
현재 진행 중인 작업도 가능한 한 취소시키고, 실행되지 않고 대기 중이던 작업은 더이상 실행시키지 않는다.

ExecutorService의 하위 클래스인 ThreadPoolExecutor는 이미 종료 절차가 시작되거나 종료된 이후에 새로운 작업을 등록하려 하면 실행 거절 핸들러(RejectedExecutionException)을 발생시켜 오류로 처리한다.

ExecutorService가 종료 상태로 들어갈 때까지 기다리고자 한다면 awaitTermination 메소드로 대기할 수도 있고, isTerminated 메소드를 주기적으로 호출해 종료 상태로 들어갔는지 확인 할 수도 있다.

### 6.2.5 지연 작업, 주기적 작업

Timer는 그 자체로 약간의 단점이 있기 때문에 가능하다면 ScheduledThreadPoolExecutor를 사용하는 방법을 생각해 보는 것이 좋다.

### Timer의 단점
* Timer 클래스는 등록된 작업을 실행시키는 스레드를 하나만 생성해 사용한다.
Timer에 등록된 특정 작업이 너무 오래 실행된다면 등록된 다른 TimerTask 작업이 예정된 시각에 실행되지 못할 가능성이 높다.
ScheduledThreadPoolExecutor를 사용하면 지연 작업과 주기적 작업마다 여러 개의 스레드를 할당해 작업을 실행하느라 각자의 실행 예정 시각을 벗어나는 일이 없도록 조절해준다.
* TimerTask가 동작하던 도중에 예상치 못한 Exception을 던져버리는 경우에 예측하지 못한 상태로 넘어갈 수 있다.
Timer클래스는 오류가 발생해 스레드가 종료된 상황에서도 자동으로 새로운 스레드를 생성해주지 않는다.

```
Timer 클래스는 상대 시작만 지원할 뿐만 아니라 절대 시각도 지원한다. 따라서 절대 시각을 사용하는 경우 시스템 하드웨어의 시작을 변경시키면 Timer에 스케줄된 작업도 함께 변경된다.
하지만 ScheduledThreadPoolExecutor는 상대 시각만 지원한다.
```

DelayQueue는 BlockingQueue를 구현한 클래스이며 Delayed를 구현한 객체를 담는다.
Delayed는 Comparable 인터페이스를 상속받으며 compareTo 메소드와 getDelay 메소드를 구현해야한다.

## 6.3 병렬로 처리할 만한 작업

### 6.3.1 예제: 순차적 페이지 렌더링

### 6.3.2 결과가 나올 때까지 대기: Callable과 Future

Runnable의 run 메소드는 실행이 끝난 다음에 뭔가 결과 값을 리턴해 줄 수도 없고, 예외가 발생할 수 있다고 thropws 구문으로 표현할 수도 없다.
`결과를 얻는 데 시간이 걸리는 기능은 Runnable 대신 Callbable을 사용하는 게 모양새가 좋다.`

Executor에서 실행한 작업은 생성(created), 등록(sumitted), 실행(started), 종료(completed) 와 같은 네 가지의 상태를 통과한다.
Executor 프레임웍에서는 먼저 등록됐지만 시작되지 않은 작업은 언제든지 실행하지 않도록 `취소` 시킬 수 있다.
이미 시작한 작업은 그 내부 구조가 인터럽트를 처리하도록 잘 만들어져 있는 경우에 한해 `취소` 시킬 수 있다.

Future 는 특정 작업이 정상적으로 완료됐는지, 아니면 취소됐는지 등에 대한 정보를 확인할 수 있도록 만들어진 클래스이다.
Future 클래스의 get 메소드는 작업이 완료 상태에 들어가 있다면 즉시 결과 값을 리턴하거나 Exception을 발생시킨다.
반면 아직 작업을 시작하지 않았거나 작업이 실행되고 있는 상태라면 작업이 완료될 때까지 대기한다.
* ExecutionException
* CancellationException

ExecutorService 클래스의 submit 메소드는 모두 Future 인스턴스를 리턴한다.
따라서 Executor에 Runnable이나 Callbable을 등록하면 Future 인스턴스를 받을 수 있고, 받은 Future 인스턴스를 사용해 작업의 결과를 확인하거나 실행 도중에 작업을 취소할 수도 있다.

### 6.3.3 예제: Future를 사용해 페이지 렌더링

Callbable과 Future 잍너페이스를 사용하면 HTML 페이지를 렌더링하는 프로그램과 같이 여러 스레드가 서로 상대방을 살펴가며 동작하는 논리 구조를 쉽게 설계할 수 있다.

### 6.3.4 다양한 형태의 작업을 병렬로 처리하는 경우의 단점

텍스트를 렌더링하는 작업이 이미지를 다운로드하는 작업보다 훨씬 빠르게 처리된다고 하면, 결과만 놓고 볼 때 전체적인 실행 시간은 순차적으로 실행되는 버전보다 그다지 빠르지 않을 것이고, 프로그램의 구조만 훨씬 복잡해질 수 있다.

### 6.3.5 CompletionService: Executor와 BlockingQueue의 연합

CompletionService는 Executor의 기능과 BlockingQueue의 기능을 하나로 모은 인터페이스이다.
* 필요한 Callable 작업을 등록해 실행시킬 수 있다.
* take나 poll과 같은 큐 메소드를 사용해 작업이 완료되는 순간 완료된 작업의 Future 인스턴스를 받아올 수 있다.
* CompletionService를 구현한 클래스로는 ExecutorCompletionService가 있다.
* 등록된 작업은 Executor를 통해 실행된다.

### 6.3.6 예제: CompletionService를 활용한 페이지 렌더링

전체 실행되는 시간을 줄일 수 있고, 응답 속도도 높일 수 있다.
각각의 이미지 파일을 다운로드 받는 작업을 생성하고, Executor를 활용해 다운로드 작업을 실행한다.

### 6.3.7 작업 실행 시간 제한

원하는 데이터를 가져올 때까지 일정 시간 동안만 기다려보고, 시간이 지나버리면 해당하는 내용 없이 페이지를 그려내도록 할 수도 있다.
타임아웃을 지정할 수 있는 Future.get 메소드를 사용하면 이와 같은 시간 제한 요구사항을 만족할 수 있다.
즉, 결과가 나오는 즉시 리턴되는 것은 타임아웃을 지정하지 않은 경우와 같지만, 지정한 시간이 지나도 결과를 만들어 내지 못하면 `TimeoutException`을 던지면서 실행이 멈추게 되어 있다.

### 6.3.8 예제: 여행 예약 포털

입찰 정보를 표시하는 페이지가 여러 업체 가운데 응답을 가장 늦게 보여주는 속도에 맞춰 뜨도록 하기 보다는, 일정 시간 안에 입찰 정보를 넘겨주는 업체에 한해서 목록을 보여주는 방법이 효과적이다.

입찰 정보를 가져오는 작업 n개를 생성해 스레드 풀에 등록하고, 등록한 작업마다 Future 객체를 확보하고, 타임아웃을 지정한 get 메소드로 각각의 입찰 정보를 가져오도록 할 수 있다.
게다가 이런 작업을 더 쉽게 만들어 주는 기능이 있는데, 바로 `invokeAll` 메소드 이다.

invokeAll 메소드는 작업 객체가 담긴 컬렉션 객체를 넘겨받으며, 그에 해당하는 Future 객체가 담긴 컬렉션 객체를 리턴한다.

## 요약
