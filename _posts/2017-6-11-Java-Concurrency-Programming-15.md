---
layout: post
title: 자바 병렬 프로그래밍 15장 단일 연산 변수와 넌블로킹 동기화
---

# 15장 단일 연산 변수와 넌블로킹 동기화

병렬 알고리즘과 관련한 최근의 연구 결과를 보면 대두분이 `넌블로킹 알고리즘`, 즉 여러 스레드가 동작하는 환경에서 데이터의 안정성을 보장하는 방법으로 락을 사용하는 대신 저수순의 하드웨어에서 제공하는 `비교 후 교환(compare and swap)` 등의 명령을 사용하는 알고리즘을 다루고 있다.

## 15.1 락의 단점

최근 사용하는 JVM은 스레드 간의 경쟁이 없는 상태에서 락을 확보하는 부분을 최적화하는 기능을 갖고 있으며 락을 해제하는 부분도 굉장히 효율적이다.
하지만 락 확보 경쟁이 벌어지는 상황에서는 JVM 역시 운영체제의 도움을 받는다.
락을 기반으로 세밀한 작업을 주로 하도록 구현돼 있는 클래스는 락에 대한 경쟁이 심해질수록 실제로 필요한 작업을 처리하는 시간 대비 동기화 작업에 필요한 시가느이 비율이 상당한 수치로 높아질 가능성이 있다.

volatile 변수를 락과 비교해 봤을 때 컨텍스트 스위칭이나 스레드 스케줄링과 아무런 연관이 없기 때문에 락보다 훨씬 가벼운 동기화 방법이다.

* 가시성 측면에서는 비슷한 수준을 보장
* 복합 연산을 하나의 단일 연산으로 처리할 수 있는 게 해주는 기능은 없다.

## 15.2 병렬 연산을 위한 하드웨어적인 지원

멀티프로세서 연산을 염두에 두고 만들어진 프로세서는 공유된 변수를 놓고 동시에 여러 작업을 해야 하는 상황을 간단하게 관리할 수 있도록 특별한 명령어를 제공한다.

초기 프로세서

* 확인하고 값 설정 (test-and-set)
* 값을 읽어와서 증가 (fetch-and-increment)
* 치환 (swap)

최근에는 거의 모든 프로세서에서 읽고-변경하고-쓰는 단일 연산을 하드웨어적으로 제공하고 있다.

* 비교하고 치환 (compare-and-swap)
* LL (load-linked) / SC (store-conditional)

### 15.2.1 비교 후 치환 (CAS)

CAS (compare-and-swap) 연산에는 3개의 인자를 넘겨주는데, 작업할 대상 메모리의 위치인 V, 예상하는 기존 값인 A, 새로 설정할 값인 B의 3개이다.
CAS 연산은 V 위치에 있는 값이 A와 같은 경우에 B로 변경하는 단일 연산이다.

만약 이전 값이 A와 달랐다면 아무런 동작도 하지 않는다. 그리고 값을 B로 변경했건 못했건 간에 어떤 경우라도 현재 V의 값을 리턴한다.

### 15.2.2 넌블로킹 카운터

많지 않은 양의 경쟁이 있는 상황에서도 CAS 기반의 클래스가 락 기반의 클래스보다 성능이 훨씬 좋고, 경쟁이 없는 경우에도 락 기반의 방법보다 나은 경우가 있다.
경쟁이 없는 상태에서 락을 확보하는 가장 빠른 경로를 생각해보면 최소한 한 번의 CAS 연산이 실행돼야 하고 락과 관련된 기본적인 작업 몇 가지도 함께 실행해야 한다.
따라서 락 기반으로 구현한 카운터 클래스에서 가장 최적의 조건으로 실행되는 경우에도 CAS 기반의 카운터 클래스에서 일반적인 경우에 해당하는 경우보다 더 많은 작업을 하는 셈이다.

락 기반의 프로그램을 보면 언어적인 문법은 훨씬 간결하지만, JVM과 운영체제가 그 락을 처리하기 위한 작업은 겉보기와 달리 그렇게 간단하지 않다.
락을 사용하면 JVM 내부에서 상당히 복잡한 코드 경로를 따라 실행하게 되고, 운영체제 수준의 락이나 스레드 대기, 컨텍스트 스위칭 등의 기능을 불러다 쓰기도 한다.

CAS 연산의 가장 큰 단점은 호출하는 프로그램에서 직접 스레드 경쟁 조건에 대한 처이를 해야 한다는 점이다.

### 15.2.3 JVM에서의 CAS 연산 지원

자바 5.0 부터는 int, long 그리고 모든 객체의 차몾를 대상으로 CAS 연산이 가능하도록 기능이 추가됐고, JVM은 CAS 연산을 호출받았을 때 해당하는 하드웨어에 적당한 가장 효괒거인 방법으로 처리하도록 돼 있다.

CAS 연산을 직접 지원하는 플랫폼의 경우라면 자바 프로그램을 실행할 때 CAS 연산 호출 부분을 직접 해당하는 기계어 코드로 변환해 실행한다.
하드웨어에서 CAS 연산을 지원하지 않는 최악의 경우에는 JVM 자체적으로 스핀 락을 사용해 CAS 연산을 구현한다.

이와 같은 `저수준의 CAS 연산은 단일 연산 변수 클래스, 즉 AtomicInteger와 같이 java.util.concureent.atomic 패키지의 AtomicXxx 클래스를 통해 제공된다`.

## 15.3 단일 연산 변수 클래스

경쟁이 없는 상태에서 단일 연산 변수의 값을 변경하는 실행 경로는 락을 확보하는 가장 빠른 코드 실행 경로보다 느릴 수 없다. (대부분 단일 연산 변수 쪽이 더 빠르게 실행된다.)
느리게 실행되는 경우를 비교해보면, 락을 사용해 구현된 부분과 같이 대기 상태에 들어가거나 스레드 스케줄링과 관련된 문제가 발생하지 않기 때문에 단일 연산 변수를 사용하는 쪽이 명백하게 더 빠르게 실행된다.

단일 연산 변수 클래스

* volatile 변수에서 읽고-변경하고-쓰는 것과 같은 조건부 단일 연산을 지원하도록 일반화한 구조이다.
* 동기화를 위한 하드웨어의 기능을 직접적으로 활용할 수 있기 때문에 경쟁이 발생하는 상황에서 훨씬 높은 확장성을 제공한다.

12개의 단일 연산 변수 클래스가 제공

* 일반 변수
* 필드 업데이터
* 배열
* 조합변수

일반 변수

* AtomicInteger
* AtomicLong
* AtomicBoolean
* AtomicReference

단일 연산 변수가 Number 클래스를 상속받고 있기는 하지만 Integer나 Long과 같은 클래스는 상속받지 않고 있다.
사실 Integer나 Long을 상속받을 수 없다는 것이 정확한 표현이다.

단일 연산 클래스는 hashCode 메소드나 equals 메소드를 재정의하고 있지 않으며, 모든 인스턴스가 서로 다른다.
내부 값을 변경할 수 있는 모든 클래스가 그렇지만, 해시 값을 기반으로 하는 컬렉션 클래스에 키 값으로 사용하기에는 적절하지 않다.

## 15.3.1 '더 나은 volatile' 변수로의 단일 연산 클래스

범위라는 조건은 항상 두 변수의 값을 동시에 사용해야 하며 필요한 조건을 만족하면서 그와 동시에 양쪽 범위 값을 동시에 없데이트할 수는 없기 때문에 volatile 참조를 사용하거나 AtomicInteger를 사용한다해도 확인하고 동작하는 연산을 안전하게 수행할 수 없다.

단일 연산 참조 변수를 사용했던 기법을 적용하면 이와 같이 두 개의 값을 갖고 있는 변경 불가능한 변수에 대한 참조를 '단일 연산으로' 변경할 때 경쟁 조건이 발생하지 않도록 할 수 있다.

### 15.3.2 성능 비교: 락과 단일 연산 변수

경쟁이 많은 상황에서는 단일 연산 변수보다 락이 더 빠르게 처리된다.
경쟁이 적거나 보통의 경쟁 수준에서는 단일 연산 변수를 사용해야 확장성을 높일 수 있다.

## 15.4 넌블로킹 알고리즘

특정 스레드에서 작업이 실패하거나 또는 대기 상태에 들어가는 경우에, 다른 어떤 스레드라도 그로 인해 실패하거나 대기 상태에 들어가지 않는 알고리즘을 `넌블로킹(non-blocking) 알로리즘`이라고 한다.
또한 각 작업 단계마다 일부 스레드는 항상 작업을 진행할 수 있는 경우 락 프리(lock-free) 알고리즘이라고 한다.

### 15.4.1 넌블로킹 스택

### 15.4.2 넌블로킹 연결 리스트

### 15.4.3 단일 연산 필드 업데이터

### 15.4.4 ABA 문제

## 요약
