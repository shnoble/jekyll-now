---
layout: post
title: 자바 병렬 프로그래밍 7장 중단 및 종료
---
# 7장 중단 및 종료

인터럽트는 특정 스레드에게 작업을 멈춰 달라고 요청하는 형태

## 7.1 작업 중단

가장 기본적인 형태는 바로 '취소 요청이 들어왔다'는 플래그를 설정하고, 실행 중인 작업은 취소 요청 플래그를 주기적으로 확인하는 방법이다.

### 7.1.1 인터럽트

취소 요청 플래그를 이용하는 취소방법은 작업 내부에서 BlockingQueue.put과 같은 블로킹 메소드를 호출하는 부분이 있다면 문제가 발생할 수 있다.

모든 스레드는 불린 값으로 인터럽트 상태를 갖고 있다. 스레드에 인터럽트를 걸면 인터럽트 상태 변수의 값이 true로 설정된다.

```java
public class Thread {
    public void interrupt() { ... }
    public boolean isInterrrupt() { ... }
    public static boolean interrupted() { ... }  // 인터럽트 해제
}
```

Thread.sleep이나 Object.wait 메소드와 같은 블로킹 메소드는 인터럽트 상태를 확인하고 있다가 인터럽트가 걸리면 즉시 리턴된다.
Thread.sleep이나 Object.wait에서 대기하던 중에 인터럽트가 걸리면 인터럽트 상태를 해제하면서 InterruptedException을 던진다.

인터럽트가 걸렸을 경우 그에 대응하는 일은 해당 스레드에서 알아서 해야한다.
```
특정 스레드의 interrupt 메소드를 호출한다 해도 해당 스레드가 처리하던 작업을 멈추지는 않는다. 단지 해당 스레드에게 인터럽트 요청이 있었다는 메시지를 전달할 뿐이다.
```

`작업 취소 기능을 구현하고자 할 때는 인터럽트가 가장 적절한 방법이라고 볼 수 있다.`

### 7.1.2 인터럽트 정책

일반적으로 가장 범용적인 인터럽트 정책은 스레드 수준이나 서비스 수준에서 작업 중단 기능을 제공하는 것이다.

### 7.1.3 인터럽트에 대한 대응

InterruptedException이 발생했을 때 처리할 수 있는 실질적인 방법에는 대략 두 가지가 있다.

* 발생한 예외를 호출 스택의 상위 메소드로 전달한다.
* 호출 스택의 상단에 위치한 메소드가 직접 처리할 수 있도록 인터럽트 상태를 유지한다.

InterruptedException을 상위 메소드로 전달할 수 없거나(Runnable 인터페이스를 구현해 작업을 정의한 경우) 전달하지 않고자 하는 상황이라면 interrupt 메소드를 다시 한번 호출한다.
catch 블록에서 InterruptedException을 잡아낸 다음 아무런 행동을 취하지 않고 말 그대로 예외를 먹어버리는 일은 하지 말아야 한다.

### 7.1.4 예제: 시간 지정 실행
 
### 7.1.5 Future를 사용해 작업 중단

ExecutorService.submit 메소드를 실행하면 등록한 작업을 나타내는 Future 인스턴스를 리턴받는다.
Future에는 cancel 메소드가 있는 ayInterruptIfRunning 이라는 불린 값을 하나 넘겨 받으며, 취소 요청에 따른 작업 중단 시도가 성공적이었는지를 알려주는 결과 값을 리턴받을 수 있다.

cancel 메소드를 호출할 때 mayInterruptIfRunning 값으로 true를 넘겨줬고 작업이 어느 스레드에서건 실행되고 있었다면, 해당 스레드에 인터럽트가 걸린다.
mayInterruptIfRunning 값으로 false를 넘겨주면 "아직 실행하지 않았다면 실행시키지 말아라"는 의미로 해석되며 인터럽트에 대응하도록 만들어지지 않은 작업에는 항상 false를 넘겨줘야 한다.
 
### 7.1.6 인터럽트에 응답하지 않는 블로킹 작업 다루기

모든 블로킹 메소드가 인터럽트에 대응하도록 되어 있지는 않다.

* java.io 패키지의 동기적 소켓 I/O
* java.nio 패키지의 동기적 I/O
* Selector를 사용한 비동기적 I/O
* 락 확보
 
### 7.1.7 newTaskFor 메소드로 `비표준적인` 중단 방법 처리

ExecutorService 클래스에 Callable 인스턴스를 동록할 때 submit 메소드를 호출하면 그 결과로 해당하는 작업을 취소시킬 수 있는 Future 객체를 받아온다. 
newTaskFor 메소드 역시 등록된 작업을 나타내는 Furue 객체를 리턴해주는데, 이전과는 다른 RunnableFuture 객체를 리턴한다.
RunnableFuture 인터페이스는 Future와 Runnable 인터페이스를 모두 상속받으며, FutureTask는 자바 5에서 Future를 구현했었지만 자바 6에서는 RunnableFuture를 구현한다.

Future.cancel 메소드를 오버라이드하면 작업 중단 과정을 원하는 대로 변경할 수 있다.
 
## 7.2 스레드 기반 서비스 중단

스레드 풀을 예로 들면, 스레드 풀에 들어 있는 모든 작업 스레드는 해당하는 스레드 풀이 소유한다고 볼 수 있고, 
따라서 개별 스레드에 인터럽트를 걸어야 하는 상황이 된다면 그 작업은 스레드를 소유한 스레드 풀에서 책임을 져야 한다.

ExecutorService 인터페이스는 shutdown 메소드와 shutdownNow 메소드를 제공하고 있으며, 다른 스레드 기반의 서비스 역시 이와같은 종료 기능을 제공해야 한다.
 
### 7.2.1 예제: 로그 서비스
 
### 7.2.2 ExecutorService 종료

* shutdown 메소드 : 안전하게 종료
* shutdownNow 메소드 : 강제로 종료

---
* 강제로 종료하는 방법
응답이 훨씬 빠르지만 실행 도중에 스레드에 인터럽트를 걸어야 하기 때문에 작업이 중단되는 과정에서 여러 가지 문제가 발생할 가능성이 있다.
* 안전하게 종료하는 방법
종료 속도가 느리지만 큐에 등록된 모든 작업을 처리할 때까지 스레드를 종료시키지 않고 놔두기 때문에 작업을 잃을 가능성이 없어 안전하다.
 
### 7.2.3 독약

프로듀서-컨슈머 패턴으로 구성된 서비스를 종료시키도록 종용하는 또 다른 방법으로 독약(Poison pill)이라고 불리는 방법이 있다.

특정 객체를 큐에 쌓도록 되어 있으며, 이 객체는 `"이 객체를 받았다면, 종료해야 한다"`는 의미를 갖고 있다. FIFO 유형의 큐를 사용하는 경우에는 독약 객체를 사용했을 때 컨슈머가 쌓여 있던 모든 작업을 종료하고 독약 객체를 만나 종료되도록 할 수 있다.
 
### 7.2.4 예제: 단번에 실행하는 서비스
 
### 7.2.5 shutdownNow 메소드의 약점

shutdownNow 메소드를 사용해 ExecutorService를 강제로 종료시키는 경우에는 현재 실행 중인 모든 스레드의 작업을 중단시키도록 시도하고, 등록됐지만 실행은 되지 않았던 모든 작업의 목록을 리턴해준다.
그런데 실행되기 시작은 했지만 아직 완료되지 않은 작업이 어떤 것인지 알아볼수 있는 방법은 없다.
 
## 7.3 비정상적인 스레드 종료 상황 처리

### 7.3.1 정의되지 않은 예외 처리
 
스레드 API를 보면 UncaughtExceptionHandler라는 기능을 제공하는데, 이 기능을 사용하면 처리하지 못한 예외 상황으로 인해 특정 스레드가 종료되는 시점을 정확히 알 수 있다.

스레드 풀의 작업 스레드를 대상으로 UncaughtExceptionHandler를 설정하려면 ThreadPoolExecutor를 생성할 때 작업용 스레드 생성을 담당하는 ThreadFactory 클래스를 별도로 넘겨주면 된다.
예외 상황이 발생했을 때 UncaughtExceptionHandler가 호출되도록 하려면 반드시 execute를 통해서 작업을 실행해야 한다.
만약, submit 메소드로 작업을 등록했다면, 그 작업에서 발생하는 모든 예외 상황은 모두 해당 작업의 리턴 상태로 처리해야 한다. 다시 말하자마녀 submit 메소드로 등록된 작업에서 예외가 발생하면 Future.get 메소드에서 해당 예외가 ExecutionException에 감싸진 상태로 넘어온다.
 
## 7.4 JVM 종료
 
### 7.4.1 종료 훅

예정된 절차대로 종료되는 경우 JVM은 가장 먼저 등록되어있는 모든 종료 훅 shutdown hook을 실행시킨다.
종료 훅은 Runtime.addShutdownHook 메소드를 사용해 등록된 아직 시작되지 않은 스레드를 의미한다.
종료 훅이 모두 작업을 마치고 나면 JVM은 runFinalizersOnExit 값을 확인해 true라고 설정되어 있으면 클래스의 finalize 메소드를 모두 호출하고 종료한다.
 
### 7.4.2 데몬 스레드

스레드는 두 가지 종류로 나눠 볼 수 있는데, 하나는 `일반 스레드`이고 다른 하나는 `데몬 스레드`이다.
JVM이 처음 시작할 때 main 스레드를 제외하고 JVM 내부적으로 사용하기 위해 실행하는 스레드(가비지 컬렉터 스레드나 기타 여러가지 부수적인 스레드)는 모두 데몬 스레드이다.
`main 스레드에서 생성한 모든 스레드는 기본적으로 데몬 스레드가 아닌 일반 스레드이다.`

스레드 하나가 종료되면 JVM은 남아있는 모든 스레드 가운데 일반 스레드가 있는지를 확인하고, 일반 스레드는 모두 종료되고 남아있는 스레드가 모두 데몬 스레드라면 즉시 JVM 종료 절차를 진행한다. 즉, JVM 이 중단될 때는 모든 데몬 스레드가 버려지는 셈이다.
`finally 블록의 코드도 실해되지 않으며, 호출 스택도 원상 복구 되지 않는다.`

> 데몬 스레드는 부수적인 단순 작업을 맡기기에 적절한 스레드이다.
 
### 7.4.3 finalize 메소드

가비지 컬렉터에 수집될 때 finalize 메소드를 호출해 실행시킨다.
finalize 메소드에서 사용하는 모든 애플리케이션 상태 변수를 다른 스레드에서도 얼마든지 동시에 사용할 수 있으며, 따라서 동기화 작업이 필수적으로 필요하다.

`finalize 메소드는 사용하지 마라`
