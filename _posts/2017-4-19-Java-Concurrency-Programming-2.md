---
layout: post
title: 자바 병렬 프로그래밍 2장 스레드 안정성
---

# 2장 스레드 안정성

* 스레드가 하나 이상 상태 변수에 접근하고 그 중 하나라도 변수에 값을 쓰면, 해당 변수에 접근할 때 관련된 모든 스레드가 동기화를 통해 조율해야 한다.
* 자바에서 동기화를 위한 기본 수단은 synchronized 키워드로서 배타적인 락을 통해 보호 기능을 제공한다.
* volatile 변수, 명시적 락, 단일 연산 변수(atomic variable)를 사용하는 경우에도 '동기화'라는 용어를 사용한다.

---
> 만약 여러 스레드가 변경할 수 있는 하나의 상태 변수를 적절한 동기화 없이 접근하면 그 프로그램은 잘못된 것이다.
> 이렇게 잘못된 프로그램을 고치는 데는 세 가지 방법이 있다.
> * 해당 상태 변수를 스레드 간에 공유하지 않거나
> * 해당 상태 변수를 변경할 수 없도록 만들거나
> * 해당 상태 변수에 접근할 땐 언제나 동기화를 사용한다.
---

* 추상화와 캡슐화 기법이 성능과 배치되기도 한다. 하지만 이런 경우 **항상 코드를 올바르게 작성하는 일이 먼저이고, 그 다음 필요한 만큼 성능을 개선**해야 한다.
* 최적화는 성능 측정을 해본 이후에 요구 사항에 미달될 때만 하는 편이 좋고, 실제와 동일한 상황을 구현해 성능을 측정하고, 예상되는 수치가 목표 수치와 차이가 있을 때만 적용해야 한다.

## 2.1 스레드 안정성이란?

* 여러 스레드가 클래스에 접근할 때, 실행 환경이 해당 스레드들들의 실행을 어떻게 스케줄하든 어디에 끼워 넣든, 호출하는 쪽에서 추가적인 동기화나 다른 조율 없이도 정확하게 동작하면 해당 클래스는 스레드 안전하다고 말한다.
* 스레드 안전한 클래스는 클라이언트 쪽에서 별도로 동기화할 필요가 없도록 동기화 기능도 캡술화한다.

### 2.1.1 예제: 상태 없는 서블릿

* 특정 계산을 위한 일시적인 상태는 스레드의 스택에 저장되는 지역 변수에만 저장하고, 실행하는 해당 스레드에서만 접근할 수 있다. 
* 상태없는 객체에 접근하는 스레드가 어떤 일을 하든 다른 스레드가 수행하는 동작의 정확성에 영향을 끼칠 수 없기 때문에 상태 없는 객체는 항상 스레드 안전하다.
`상태 없는 객체는 항상 스레드에 안전하다`

## 2.2 단일 연산

### 2.2.1 경쟁 조건
* 경쟁조건은 상대적인 시점이나 또는 여러 스레드를 교차해서 싫랭하는 상황에 따라 계산의 정확성이 달라질 때 나타난다.
* 가장 일반적인 경쟁 조건 형태는 **잠재적으로 유효하지 않는 값을 참조해서 다음에 뭘 할지를 결정하는 점검 후 행동 (check-then-act) 형태의 구문**이다.

> 경쟁 조건(race condition) 이라는 용어는 종종 관련된 용어인 데이터 경쟁(data race)와 혼동되기도 한다. 데이터 경쟁은 공유된 final이 아닌 필드에 대한 접근을 동기화로 보호하지 않았을 때 발생한다. 스레드가 다음에 다른 스레드가 읽을 수 있는 변수에 값을 쓰거나 다른 스레드가 마지막에 수정했을 수도 있는 변수를 읽을 때 두 스레드 모두 동기화를 하지 않으면 데이터 경쟁이 생길 위험이 있다. 데이터 경쟁이 있는 코드는 자바 메모리 모델 하에선 유용한 정의된 의미가 없다. 모든 경쟁 조건이 데이터 경쟁인 건 아니고, 모든 데이터 경쟁이 경쟁 조건인 것도 아니다. 하지만 경쟁 조건이든 데이터 경쟁이든 병렬 프로그램을 예측할 수 없이 실패하게 만든다. 

### 2.2.2 예제: 늦은 초기화 시 경쟁 조건

```java
@NotThreadSafe
public class LazyInitRace {
    private ExpensiveObject instance = null;
    
    public ExpensiveObject getInstance() {
        if (instance == null) 
            instance = new ExpensiveObject();
        return instance;
    }
}
```

LazyInitRace는 경쟁 조건 때문에 제대로 동작하지 않을 가능성이 있다.

### 2.2.3 복합 동작

* 작업 A를 싱행 중인 스레드 관점에서 다른 스레드가 작업 B를 실행할 때 작업 B가 모두 수행됐거나 또는 전혀 수행되지 않은 두가지 상태로만 파악된다면 작업 A의 눈으로 볼때 작업  B는 단일 연산이다. 단일 연산 작업은 자신을 포함해 같은 상태를 다루는 모든 작업이 단일 연산인 작업을 지칭한다.
* 스레드 안정성을 보장하기 위해 검검 후 행동과 읽고 수정하고 쓰기 등의 작업은 항상 단일 연산이어야 한다.
* 점검 후 행동과 읽고 수정하고 쓰기 같은 일련의 동작을 복합 동작 (compound action)이라고 한다.
* 즉, `스레드에 안전하기 위해서는 전체가 단일 연산으로 실행돼야 하는 일련의 동작을 지칭`한다.

> java.util.concurrent.atomic 패키지에는 숫자나 객체 참조 값에 대해 상태를 단일 연산으로 변경할 수 있도록 단일 연산 변수 (atomic variable) 클래스가 준비돼 있다.

## 2.3 락

### 2.3.1 암묵적인 락

* 자바에는 단일 연산 특성을 보장하기 위해 **synchronized**라는 구문으로 사용할 수 있는 락을 제공한다.
* synchronized 구문은 락으로 사용될 객체의 참조 값과 해당 락으로 보호하려는 코드 블록으로 구성된다.

#### 메소드 선언부 synchronized
* 메소드 선언 부분에 synchronized 키워드를 지정하면 **메소드 내부의 코드 전체를 호함하면서 메소드가 포함된 클래스의 인스턴스를 락으로 사용하는 synchronize 블록을 간략하게 표현**한 것으로 볼 수 있다..

#### static 메소드 선언부 synchronized
* static으로 선언한 synchronized 메소드는 해당 Class 객체를 락으로 사용한다.

> 모든 자바 객체는 락으로 사용할 수 있다.
> 이와 같이 자바에 내장된 락을 암묵적인 락(intrinsic lock) 혹은  모니터 락(monitor lock)이라고 한다.

`자바에서 암묵적인 락은 뮤텍스(mutexs 또는 mutual exclusion lock(상호 배체 락))로 동작한다.`

### 2.3.2 재진입성



## 2.4 락으로 상태 보호하기

## 2.5 활동성과 성능
