---
layout: post
title: 자바 병렬 프로그래밍 2장 스레드 안정성
---

# 2장 스레드 안정성

* 스레드가 하나 이상 상태 변수에 접근하고 그 중 하나라도 변수에 값을 쓰면, 해당 변수에 접근할 때 관련된 모든 스레드가 동기화를 통해 조율해야 한다.
* 자바에서 동기화를 위한 기본 수단은 synchronized 키워드로서 배타적인 락을 통해 보호 기능을 제공한다.
* volatile 변수, 명시적 락, 단일 연산 변수(atomic variable)를 사용하는 경우에도 '동기화'라는 용어를 사용한다.

---
> 만약 여러 스레드가 변경할 수 있는 하나의 상태 변수를 적절한 동기화 없이 접근하면 그 프로그램은 잘못된 것이다.
> 이렇게 잘못된 프로그램을 고치는 데는 세 가지 방법이 있다.
> * 해당 상태 변수를 스레드 간에 공유하지 않거나
> * 해당 상태 변수를 변경할 수 없도록 만들거나
> * 해당 상태 변수에 접근할 땐 언제나 동기화를 사용한다.
---

* 추상화와 캡슐화 기법이 성능과 배치되기도 한다. 하지만 이런 경우 **항상 코드를 올바르게 작성하는 일이 먼저이고, 그 다음 필요한 만큼 성능을 개선**해야 한다.
* 최적화는 성능 측정을 해본 이후에 요구 사항에 미달될 때만 하는 편이 좋고, 실제와 동일한 상황을 구현해 성능을 측정하고, 예상되는 수치가 목표 수치와 차이가 있을 때만 적용해야 한다.

## 2.1 스레드 안정성이란?

* 여러 스레드가 클래스에 접근할 때, 실행 환경이 해당 스레드들들의 실행을 어떻게 스케줄하든 어디에 끼워 넣든, 호출하는 쪽에서 추가적인 동기화나 다른 조율 없이도 정확하게 동작하면 해당 클래스는 스레드 안전하다고 말한다.
* 스레드 안전한 클래스는 클라이언트 쪽에서 별도로 동기화할 필요가 없도록 동기화 기능도 캡술화한다.

### 2.1.1 예제: 상태 없는 서블릿

* 특정 계산을 위한 일시적인 상태는 스레드의 스택에 저장되는 지역 변수에만 저장하고, 실행하는 해당 스레드에서만 접근할 수 있다. 
* 상태없는 객체에 접근하는 스레드가 어떤 일을 하든 다른 스레드가 수행하는 동작의 정확성에 영향을 끼칠 수 없기 때문에 상태 없는 객체는 항상 스레드 안전하다.
`상태 없는 객체는 항상 스레드에 안전하다`

## 2.2 단일 연산

### 2.2.1 경쟁 조건
* 경쟁조건은 상대적인 시점이나 또는 여러 스레드를 교차해서 싫랭하는 상황에 따라 계산의 정확성이 달라질 때 나타난다.
* 가장 일반적인 경쟁 조건 형태는 **잠재적으로 유효하지 않는 값을 참조해서 다음에 뭘 할지를 결정하는 점검 후 행동 (check-then-act) 형태의 구문**이다.

> 경쟁 조건(race condition) 이라는 용어는 종종 관련된 용어인 데이터 경쟁(data race)와 혼동되기도 한다. 데이터 경쟁은 공유된 final이 아닌 필드에 대한 접근을 동기화로 보호하지 않았을 때 발생한다. 스레드가 다음에 다른 스레드가 읽을 수 있는 변수에 값을 쓰거나 다른 스레드가 마지막에 수정했을 수도 있는 변수를 읽을 때 두 스레드 모두 동기화를 하지 않으면 데이터 경쟁이 생길 위험이 있다. 데이터 경쟁이 있는 코드는 자바 메모리 모델 하에선 유용한 정의된 의미가 없다. 모든 경쟁 조건이 데이터 경쟁인 건 아니고, 모든 데이터 경쟁이 경쟁 조건인 것도 아니다. 하지만 경쟁 조건이든 데이터 경쟁이든 병렬 프로그램을 예측할 수 없이 실패하게 만든다. 

### 2.2.2 예제: 늦은 초기화 시 경쟁 조건

```java
@NotThreadSafe
public class LazyInitRace {
    private ExpensiveObject instance = null;
    
    public ExpensiveObject getInstance() {
        if (instance == null) 
            instance = new ExpensiveObject();
        return instance;
    }
}
```

LazyInitRace는 경쟁 조건 때문에 제대로 동작하지 않을 가능성이 있다.

### 2.2.3 복합 동작

* 작업 A를 싱행 중인 스레드 관점에서 다른 스레드가 작업 B를 실행할 때 작업 B가 모두 수행됐거나 또는 전혀 수행되지 않은 두가지 상태로만 파악된다면 작업 A의 눈으로 볼때 작업  B는 단일 연산이다. 단일 연산 작업은 자신을 포함해 같은 상태를 다루는 모든 작업이 단일 연산인 작업을 지칭한다.
* 스레드 안정성을 보장하기 위해 검검 후 행동과 읽고 수정하고 쓰기 등의 작업은 항상 단일 연산이어야 한다.
* 점검 후 행동과 읽고 수정하고 쓰기 같은 일련의 동작을 복합 동작 (compound action)이라고 한다.
* 즉, `스레드에 안전하기 위해서는 전체가 단일 연산으로 실행돼야 하는 일련의 동작을 지칭`한다.

> java.util.concurrent.atomic 패키지에는 숫자나 객체 참조 값에 대해 상태를 단일 연산으로 변경할 수 있도록 단일 연산 변수 (atomic variable) 클래스가 준비돼 있다.

## 2.3 락

### 2.3.1 암묵적인 락

* 자바에는 단일 연산 특성을 보장하기 위해 **synchronized**라는 구문으로 사용할 수 있는 락을 제공한다.
* synchronized 구문은 락으로 사용될 객체의 참조 값과 해당 락으로 보호하려는 코드 블록으로 구성된다.

#### 메소드 선언부 synchronized
* 메소드 선언 부분에 synchronized 키워드를 지정하면 **메소드 내부의 코드 전체를 호함하면서 메소드가 포함된 클래스의 인스턴스를 락으로 사용하는 synchronize 블록을 간략하게 표현**한 것으로 볼 수 있다..

#### static 메소드 선언부 synchronized
* static으로 선언한 synchronized 메소드는 해당 Class 객체를 락으로 사용한다.

> 모든 자바 객체는 락으로 사용할 수 있다.
> 이와 같이 자바에 내장된 락을 암묵적인 락(intrinsic lock) 혹은  모니터 락(monitor lock)이라고 한다.

`자바에서 암묵적인 락은 뮤텍스(mutexs 또는 mutual exclusion lock(상호 배체 락))로 동작한다.`

### 2.3.2 재진입성

* 스레드가 다른 스레드가 가진 락을 요청하면 해당 스레드는 대기 상태에 들어간다.
* 암묵적인 락은 재진입 가능 (reentrant) 하기 때문에 특정 스레드가 자기가 이미 획득한 락을 다시 확보 할 수 있다.

> 재진입성을 구현하려면 각 락마다 확보 횟수와 확보한 스레드를 연결시켜 둔다.
> 확보 획수가 0이면 락은 해제된 상태이다. 스레드가 해제된 락을 확보하면 JVM이 락에 대한 소유 스레드를 기록하고 확보 횟수를 1로 지정한다. 같은 스레드가 락을 다시 얻으면 횟수를 증가시키고, 소윻한 스레드가 sychronized 블록 밖으로 나가면 횟수를 감소시킨다. 이렇게 횟수가 0이 되면 해당 락은 해제된다.


## 2.4 락으로 상태 보호하기

* 여러 변수에 대한 불변조건이 있으면 해당 변수들은 모두 같은 락으로 보호해야 한다.

## 2.5 활동성과 성능

 * synchronized 블록의 범위를 줄이면 스레드 안전성을 유지하면서 쉽게 동시성을 향상 시킬 수 있다.
 * synchronized 블록의 크기를 적정하게 유지하려면 안정성, 단순성, 성능 등의 서로 상충하는 설계 원칙 사이에 적절한 타협이 필요할 수 있다.

```
종종 단순성과 성능이 서로 상충할 때가 있다. 동기화 정책을 구현할 때는 성능을 위해 조급하게 단순성을(잠재적으로 안정성을 훼손하면서)을 희생하고픈 유혹을 버려야 한다.
```

* 계산량이 많은 작업을 하거나 잠재적으로 대기 상태에 들어 갈 수 있는 작업을 하느라 락을 오래 잡고 있으면 활동성이나 성능 문제를 야기할 수 있다.

```
복잡하고 오래 걸리는 계산 작업, 네트웍 작업, 사용자 입출력 작업과 같이 빨리 끝나지 않을 수 있는 작업을 하는 부분에서는 가능한 한 락을 잡지 말아라.
```
