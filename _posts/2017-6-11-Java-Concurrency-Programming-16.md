---
layout: post
title: 자바 병렬 프로그래밍 16장 자바 메모리 모델
---

# 16장 자바 메모리 모델

## 16.1 자바 메모리 모델은 무엇이며, 왜 사용해야 하는가?

### 16.1.1 플랫폼 메모리 모델

메모리를 공유하는 멀티프로세서 시스템은 보통 각자의 프로세서 안에 캐시 메모리를 갖고 있으며, 캐시 메모리의 내용은 주기적으로 메인 메모리와 동기화 된다.

시스템 구조에서 말하는 메모리 모델(memory model)은 프로그램이 메모리 구조에서 어느 정도의 기능을 사용할 수 있을지에 대한 정보를 제공하고, 메모리의 내용을 서로 공유하고자 할 때 프로세서 간의 작업을 조율하기 위한 특별한 명령어(메모리 배리어(memory barrier) 또는 펜스(fence))로는 어떤 것들이 있으며 어떻게 사용해야 하는지에 대한 정보도 제공한다.

순차적 일관성(sequential consistency)

* 프로그램이 실행되는 과정에서 변수에 마지막으로 설정된 값을 어떤 프로세서건 간에 정확하게 읽어낼 수 있다.

그러나 `현재 사용중인 어떤 프로세서도 순차적 일관성을 지원하지 않으며 JMM 역시 지원하지 않는다.`

### 16.1.2 재배치

특정 작업이 지연되거나 다른 순서로 실행되는 것처럼 보이는 문제를 `재배치(reordering)`이라는 용어로 통일해서 표현한다.

### 16.1.3 자바 메모리 모델을 간략하게 설명한다면

변수를 읽거나 쓰는 작업, 모니터를 잠그거나 해제하는 작업, 스레드를 시작하거나 끝나기를 기다리는 작업과 같이 여러 가지 작업에 대해 자바 메모리 모델(JMM)을 정의한다.
JMM에서는 프로그램 내부의 모든 작업을 대상으로 미리 발생(happens-before)라는 부분 재배치(partial reordering) 연산을 정의하고 있다.
작업 A가 실행된 결과를 작업 B에서 볼 수 있다는 점을 보장하기 위해 작업 A와 B 사이에는 미리 발생 관계가 갖춰져야 한다.
두 개 작업 간에 미리 발생 관계가 갖춰져 있지 않다면 JVM은 원하는 대로 해당 작업을 재배치 할 수 있게 된다.

미리 발생 현상에 대한 규칙

* 프로그램 순서 규칙
* 모니터 잠금 규칙
* volatile 변수 규칙
* 스레드 시작 규칙
* 스레드 완료 규칙
* 인터럽트 규칙
* 완료 메소드(finalizer) 규칙
* 전이성(transitivity)

### 16.1.4 동기화 피기백

## 16.2 안전한 공개

### 16.2.1 안전하지 못한 공개

객체에 대한 참조를 공개하는 과정에는 또 다른 변수, 즉 새로운 객체에 대한 참조에 값을 쓴느 작업이 동반된다.
프로그램상에서 공유된 참조를 공개하는 일이 다른 스레드에서 해당 참조를 읽어가는 일보다 미리 발생하도록 확실하게 해두지 않으면 새로운 객체에 대한 참조에 값을 쓰는 작업과 객체 내부의 변수에 값을 쓰는 과정에서 재배치가 일어날 수 있다.

### 16.2.2 안전한 공개

### 16.2.3 안전한 초기화를 위한 구문

### 16.2.4 더블 체크 락

## 16.3 초기화 안전성
