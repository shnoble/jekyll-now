# 3장 명시적인 락

자바 5.0에서 ReentrantLock이 추가되었다.

## 13.1 Lock과 ReentrantLock

Lock 인터페이스는

* 암묵적인 락과 달리 조건 없는 (unconditional) 락
* 폴링 락
* 타임아웃이 있는 락
* 락 확보 대기 상태에 인터럽트를 걸수 있는 방법

등이 포함되어 있다.

synchronized를 사용하는 암묵적인 락보다 좀 복잡한 규칙도 있는데 바로 finally 블록에서 반드시 락을 해제해야 한다는 점이다.

### 13.1.1 폴링과 시간 제한이 있는 락 확보 방법

락을 확보할 때 시간 제한을 두거나 폴링을 하도록 하면 확률적으로 데드락을 회피할 수 있다.

tryLock 메소드에 타임아웃을 지정해 사용하면 시간이 제한된 작업 구조에 락을 함께 적용해 활용하기 좋다.

### 13.1.2 인터럽트 걸 수 있는 락 확보 방법

일정 시간 안에 처리해야 하는 작업을 실행하고 있을 때 타임아웃을 걸 수 있는 락 확보 방법을 유용하게 사용할 수 있는 것 처럼, `작업 도중 취소시킬 수 있어야 하는 작업인 경우에는 인터럽트를 걸 수 있는 락 확보 방법` 유용하게 사용할 수 있다.

암묵적인 락은 인터럽트에 전혀 반응하지 않는다.

`lockInterruptibly 메소드`를 사용하면 인터럽트는 그대로 처리할 수 있는 상태에서 락을 확보한다.

인터럽트에 대응할 수 있는 방법으로 락을 확보하는 코드의 구조는 일반적으로 락을 확보하는 모습보다 약간 복잡하긴 한데, 두 개의 try 구문을 사용해야 한다.
타임아웃을 지정하는 tryLock 메소드 역시 인터럽트를 걸면 반응하도록 돼 있으며, 인터럽트를 걸어 취소키실 수도 있어야 하면서 동시에 타임아웃을 지정할 수 있어야 한다면 tryLock을 사용하는 것만으로 충분하다.

### 13.1.3 블록을 벗어나는 구조의 락

암묵적인 락을 사용하는 경우에는 락을 확보하고 해제하는 부분이 완벽하게 블록의 구조에 맞춰져 있으며, 블록을 어떤 상태로 떠나는지에 관계 없이 락은 항상 자신을 확보했던 블록이 끝나는 시점에 자동으로 해제된다.
하지만 좀더 복잡한 구조의 프로그램에 락을 적용해야 할 때는 이보다 훨씬 유연한 방법으로 락을 걸 수 있어야 한다.

## 13.2 성능에 대한 고려 사항

자바 5.0과 함께 ReentrantLock이 처음 소개됐을 때 암묵적인 락에 비해 훨씬 나은 경쟁 성능 (contended performance)을 보여줬다.
자바 6에서는 암묵적인 락을 관리하는 부분에 ReentrantLock에서 사용하는 것과 같이 좀더 향상된 알고리즘을 사용하며, 그에 따라 확장성에서 큰 차이가 나던 것이 많이 비슷해졌다.

## 13.3 공정성

ReentrantLock 클래스는 두 종류의 공정성 설정을 지원한다.

* 불공정 (nonfair) 락
    * 순서 뛰어넘기(barging)가 일어나기도 하는데, 락을 확보하려고 대기하는 큐에 대기 중인 스레드가 있다 하더라도 해제된 락이 있으면 대기자 목록을 뛰어 넘어 락을 확보할 수 있다.
* 공정 (fair) 락
    * 요청한 순서를 지켜가면서 락을 확보

`결론은 불공정한 락이 공정한 락보다 성능이 좋다.`

스레드 간의 경쟁이 심하게 나타나는 상황에서 락을 공정하게 관리하는 것보다 불공정하게 관리하는 방법의 성능이 훨씬 빠른 이유는 대기 상태에 있던 스레드가 다시 실행 상태로 돌아가고 또한 실제로 실행되기 까지는 상당한 시간이 걸리기 때문이다.

공정한 방법으로 락을 관리할 때는 락을 확보하고 사용하기는 시간이 상대적으로 길거나 락 요청이 발생하는 시간 간격이 긴 경우에 유리하다.

## 13.4 Synchronized 또는 ReentranctLock 선택

ReentrantLock은 락 능력이나 메모리 측면에서 synchronized 블록과 동일한 형태로 동작하면서도 락을 확보할 때 타임아웃을 지정하거나 대기 상태에서 인터럽트에 잘 반응하고 공정성 여부를 지정할 수도 있으며 블록의 구조를 갖추고 있지 않은 경우에도 락을 적용할 수 있는 유연함을 갖고 있다.

ReentrantLock 은 암묵적인 락으로는 해결할 수 없는 복잡한 상황에서 사용하기 위한 고급 동기화 기능이다.
다음과 같은 고급 동기화 기법을 사용해야 하는 경우에만 ReentrantLock을 사용하도록 하자

* 락을 확보할 때 타임아웃을 지정해야 하는 경우
* 폴링의 형태로 락을 확보하고자 하는 경우
* 락을 확보하느라 대기 상태에 들어가 있을 때 인터럽트를 걸 수 있어야 하는 경우
* 대기 상태 큐 처리 방법을 공정하게 해야 하는 경우
* 코드가 단일 블록의 형태를 넘어서는 경우

그 외의 경우에는 synchonized 블록을 사용하도록 하자

자바 5.0에서는 synchronized 블록이 ReentrantLock 에 비해 갖고 있는 장접이 하나 더 있다.

* 스레드 덤프를 떠보면 어느 스레드의 어느 메소드에서 어느 락을 확보하고 있고, 데드락에 걸린 스레드가 있는지, 어디에서 데드락에 걸렸는지도 표시해준다.
* 반면에 JVM 입장에서는 ReentrantLock이 어느 스레드에서 사용됐는지를 알 수 없기 때문에 동기화 관련 문제가 발생했을 때 JVM을 통해서 문제를 해결하는 데 도움이 될 정보를 얻기가 어렵다.
* 자바 6에서는 ReentrantLock의 이런 단점이 해소 됐는데, 락이 등록할 수 있는 관리 및 모니터링 인터페이스가 추가됐다.

## 13.5 읽기 -쓰기 락

대부분의 경우 사용하는 데이터 구조는 읽기 작업이 많이 일어난다.
해당 데이터 구조를 사용하는 모든 스레드가 가장 최신의 값을 사용하도록 보장해주고, 데이터를 읽거나 보고 있는 상태에서는 다른 스레드가 변경하지 못하도록 하면 아무런 문제가 없다.
즉, 읽기 작업은 여러 개를 한꺼번에 처리할 수 있지만 쓰기 작업은 혼자만 동작할 수 있는 구조의 동기화를 처리해주는 락이 바로 `읽기-쓰기 락(read-write lock)`이다.

ReadWriteLock은 구현상의 복잡도가 약간 높기 때문에 최적화된 상황이 아닌 곳에 적용하면 상호 배제시키는 일반적인 락에 비해서 성능이 약간 떨어지기도 한다.
특정 상황을 놓고 ReadWriteLock을 사용하는 것이 적절한 것인지에 대한 대답은 성능 프로파일링을 통해서만 얻을 수 있다.

## 요약

ReentrantLock에서만 제공되고 synchronized 구문은 제공하지 않는 동기화 관련 기능이 꼭 필요한 경우에만 ReentrantLock을 사용하도록 하자.
