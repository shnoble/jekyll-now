---
layout: post
title: 자바 병렬 프로그래밍 14장 동기화 클래스 구현
---

# 14장 동기화 클래스 구현

원하는 기능을 제공하는 클래스가 JDK 라이브러리에 포함돼 있지 않다면 자바 언어와 JDK 라이브러리에서 제공하는 저수준의 기능을 활용해 원하는 기능을 만들어 사용할 수도 있다.

여기서 저수준의 기능이라 함은

* 암묵적인 조건큐 (condition queue)
* 명시적인 Condition 객체
* AbstractQueueedSynchronizer 프레임웍

등을 말한다.

14장은 상태 종속성을 만들어 낼 수 있는 다양한 방법에 대해서 알아보고, 자바 플랫폼에서 제공하는 상태 종속성에 적용되는 여러 가지 규칙에 대해서도 살펴본다.

## 14.1 상태 종속성 관리

자바에 내장된 조건 큐 메커니즘 (condition queue mechanism)은 실행 중인 스레드가 특정 객체가 원하는 상태에 진입할 때까지 대기할 수 있도록 도와주며, 원하는 상태에 도달해서 스레드가 계속해서 실행할 수 있게 되면 대기 상태에 들어가 있던 스레드를 깨워주는 역할도 담당한다.

### 14.1.1 예제: 선행 조건 오류를 호출자에게 그대로 전달

### 14.1.2 예제: 폴링과 대기를 반복하는 세련되지 못한 대기 상태

### 14.1.3 조건 큐 - 문제 해결사

조건 큐는 여러 스레드를 한 덩어리로 묶어 특정 조건이 만족할 때까지 한꺼번에 대기할 수 있는 방법을 제공하기 때문에 '조건 큐'라는 이름으로 불린다.
자바 언어에서 사용하는 모든 객체를 락으로 활용할 수 있는 것처럼 모든 객체는 스스로를 조건 큐로 사용할 수 있다.

* Object.wait()
    * 현재 확보하고 있는 락을 자동으로 해제하면서 운영체제에게 현재 스레드를 멈춰달라고 요청하고, 따라서 다른 스레드가 락을 확보해 객체 내부의 상태를 변경할 수 있도록 해준다.
    * 대기 상태에서 깨어나는 순간에는 해제했던 락을 다시 확보한다.
    * "나는 대기 상태에 들어갈 예정인데, 만약 뭔가 재미있는 일이 생기면 깨워주기 바랍니다."
* Object.notify() or Object.notifyAll()
    * "뭔가 재미있는 일이 발생했습니다."

## 14.2 조건 큐 활용 (wait, notify, notifyAll)

컴파일러나 자바 플랫폼에서 정의하고 있지는 않지만, 조건 큐를 제대로 활용하려면 꼭 지켜야만 하는 몇 가지 규칙이 있다.

* 조건 서술어
* 너무 일찍 깨어나기
    * wait 메소드를 호출하고 리턴 됐다고 해서 반드시 조건 서술어를 만족한다는 것은 아니다.
* 놓친 신호
* 알림
* 하위 클래스 안정성 문제
* 조건 큐 캡슐화
* 진입 규칙과 완료 규칙

### 14.2.1 조건 서술어

조건 큐를 올바로 사용하기 위한 가장 핵심적인 요소는 바로 해당 객체가 대기하게 될 조건 서술어 (predicate)를 명확하게 구분해내는 일이다.

```
조건 큐에 연결된 조건 서술어를 항상 문서로 남겨야 하며, 그 조건 서술어에 영향을 받는 메소드가 어느 것인지도 명시해야 한다.
```

조건부 대기와 관련된 락과 wait 메소드와 조건 서술어는 중요한 삼각 관계를 유지하고 있다.
* 조건 서술어는 상태 변수를 기반으로 하고 있고, 상태 변수를 락으로 동기화돼 있으니 조건 서술어를 만족하는지 확인하려면 반드시 락을 확보해야만 한다.
* 락 객체와 조건 큐 객체(wait와 notify 메소드를 호출하는 대상 객체)는 반드시 동일한 객체여야만 한다.

wait 메소드는 먼저 락을 해제하고 현재 스레드를 대기 상태에 두고, 일정 시간 이후에 타임아웃이 발생하거나 스레드에 인터럽트가 걸리거나 notify 또는 notify
All을 통해 알림을 받을 때까지 대기 한다.

### 14.2.2 너무 일찍 깨어나기

wait 메소드를 호출하고 리턴됐다고 해서 반드시 해당 스레드가 대기하고 있던 조건 서술어를 만족한다는 것은 아니다.

* 하나의 암묵적인 조건 큐를 두 개 이상의 조건 서술어를 대상으로 사용할 수도 있다.
* 어디에선가 notifyAll을 호출해서 대기 상태에 있던 스레드가 깨어났다면, wait 메소드가 리턴됐다고 해서 wait 하기 직전에 확인했던 조건 서술어를 만족하게 됐다는 것으로 이해해서는 안된다.

`락을 확보하고 보니 다시 조건 서술어를 만족하지 않는 상태가 됐을 가능성도 있다.`
하나의 조건 큐에 여러 개의 조건 서술어를 연결해 사용할 수도 있다.

조건부 wait 메소드(Object.wait 또는 Condition.wait)을 사용할 때는

* 항상 조건 서술어(작업을 계속 진행하기 전에 반드시 확인해야 하는 확인 절차)를 명시해야 한다.
* wait 메소드를 호출하기 전에 조건 서술어를 확인하고, wait에서 리턴된 이후에도 조건 서숭러을 확인해야 한다.
* `wait 메소드는 항상 반복문 내부에서 호출해야 한다.`
* 조건 서술어를 확인하는 데 관련된 모든 상태 변수를 해단 조건 큐의 락에 의해 돈기화 돼 있어야 한다.
* wait, notify, notifyAll 메소드를 호출할 때는 조건 큐에 해당하는 락을 확보하고 있어야 한다.
* 조건 서술어를 확인한 이후 실제로 실행해 작업이 끝날 때까지 락을 해제해서는 안된다.

### 14.2.3 놓친 신호

특정 스레드가 이미 참(true)을 만족하는 조건을 놓고 조건 서술어를 제대로 확인하지 못해 대기 상태에 들어가는 상황을 `놓친 신호`라고 한다.

스레드 A가 조건 큐에 신호를 보내주고, 신호가 지나간 이후에 스레드 B가 동일한 조건 큐에서 대기한다면 스레드 B는 대기 상태에서 깨어나지 못한다.
예를 들어, wait 메소드를 호출하기 전에 조건 서술어를 확인하지 못하는 경우가 생길 수 있다면 놓친 신호가 문제가 발생할 가능성도 있다.

### 14.2.4 알림

```
특정 조건을 놓고 wait 메소드를 호출해 대기 상태에 들어간다면, 해당 조건을 만족하게된 이후에 반드시 알림 메소드를 사용해 대기 상태에서 빠져나오도록 해야 한다.
```

조건 큐 API 에서 알림 기능을 제공하는 메소드는 두가지가 있다.

* notify
    * notify. 메소드를 호출하면 JVM은 해당하는 조건 큐에서 대기 상태에 들어가 있는 다른 스레드 하나를 골라 대기 상태를 풀어준다.
* notifyAll
    * notifyAll 메소드를 호출하면 해당하는 조건 큐에서 대기 상태에 들어가 있는 모든 스레드를 풀어준다.

두 메소드 모두 조건 큐 객체에 대한 락을 확보한 상태에서만 호출할 수 있다.
notify 또는 notifyAll 을 호출한 이후에는 최대한 빨리 락을 풀어줘야 대기 상태에서 깨어난 스레드가 얼른 동작할 수 있다.

`여러 개의 스레드가 하나의 조건 큐를 놓고 대기 상태에 들어갈 수 있는데, 대기 상태에 들어간 조건이 서로 다를 수 있기 때문에 notifyAll 대신 notify 메소드를 사용해 대기 상태를 풀어주는 방법은 위험성이 높다.`

notifyAll 대신 notify를 사용하려면 다음과 같은 조건에 해당하는 경우에만 사용하는 것이 좋다.

* 단일 조건에 따른 대기 상태에서 깨우는 경우
    * 해당하는 조건 큐에 단 하나의 조건만 사용하고 있는 경우이고, 따라서 각 스레드는 wait 메소드에서 리턴될 때 동일한 방법으로 실행된다.
* 한번에 하나씩 처리하는 경우
    * 조건 변수에 대한 알림 메소드를 호출하면 하나의 스레드만 실행시킬 수 있는 경우

#### 조건부 알림

버퍼가 비어 있다가 값이 들어오거나 가득 찬 상태에서 값을 뽑아 내는 경우에만 대기 상태에서 빠져나올 수 있다는 점을 활용해 take나 put 메소드가 대기 상태에서 빠져나올 수 있는 상태를 만들어주는 경우에만 알림 메소드를 호출하도록 하면 최적화 할 수 있다.
이런 최적화 방법을 `조건부 알림(conditional notification)`이라고 부른다.

그러나 "일단 제대로 동작하게 만들어라. 그리고 필요한 만큼 속도가 나지 않는 경우에만 최적화를 진행하라"는 원칙을 먼저 지킬 필요가 있다.

### 14.2.5 예제: 게이트 클래스

### 14.2.6 하위 클래스 안정성 문제

### 14.2.7 조건 큐 캡슐화

### 14.2.8 진입 규칙과 완료 규칙

## 14.3 명시적인 조건 객체 (Condition 클래스)

명시적으로 Lock 객체를 사용하면 암묵적인 락이 호라용 형태가 지극히 제한돼 있어 처리할 수 없던 동기화 기능도 수행할 수 있다.
암묵적인 락을 일반화한 형태가 Lock 클래스인 것처럼 암묵적인 조건 큐를 일반화한 형태를 바로 `Condition 클래스`이다.

암묵적인 조건 큐에는 여러가지 단점이 있다. 모든 암묵적인 락 하나는 조건 큐를 단 하나만 가질 수 있다.

* 암묵적인 락이나 조건 큐 대신 Lock 클래스와 Condition 클래스를 활용하면 여러 가지 종류의 조건을 사용하는 병렬 처리 객체를 구현하거나 조건 큐를 노출시키는 것에 대한 공부를 할 때 훨씬 유연하게 대처할 수 있다.
* 암묵적인 조건 큐가 암묵적인 락 객체를 사용해 동기화하는 것처럼 Condition 클래스 역시 내부적으로 하나의 Lock 클래스를 사용해 동기화를 맞춘다.
* Condition 인스턴스를 생성하려면 Lock.newCondition 메소드를 호출한다.

Lock 클래스가 암묵적인 락보다 훨씬 다양한 기능을 제공하는 것처럼 Condition 클래스 역시

* 하나의 락에 여러 조건으로 대기
* 인터럽트에 반응하거나 반응하지 않는 대기 상태
* 데드라인을 정해둔 대기 상태
* 공정하거나 공정하지 않은 큐 처리

등 암묵적인  조건 큐보다 훨씬 다양한 기능을 제공한다.

Condition 객체는 암묵적인 조건 큐와 달리 Lock 하나를 대상으로 필요한 만큼 몇 개라도 만들 수 있다.
Condition 객체는 자신을 생성해준 Lock 객체의 공정성을 그대로 물려받는데, 이를 테면 공정한 Lock에서 생성된 Conditino 객체의 경우에는 Condition.wait 메소드에서 리턴될 때 정확하게 FIFO 순서를 따른다.

```
위험성 경고!!
암묵적인 락에서 사용하던 wait, notify, notifyAll 메소드의 기능은 Condition 클래스에서는 각각 await, signal, signalAll 메소드이다.
자바에서 모든 클래스가 그렇지만 Condition 클래스 역시 Object를 상속받기 때문에 Condition 객체에도 wait, notify, notifyAll 메소드가 포함돼 있다.
따라서 실수로 awiat 대신 wait 메소드를 사용하거나 notify 대신 signal 메소드를 사용하면 동기화 기능에 큰 문제가 생길 수 있다.
```

조건을 확인하거나 await 또는 signal 메소드를 호출하는 시점에는 반드시 Lock을 확보한 상태여야 한다.
공정한 큐 관리 방법이나 하나의 락에서 여러 개의 조건 큐를 사용할 필요가 있는 경우라면 Condition 객체를 사용하고, 그럴 필요가 없다면 암묵적인 조건 큐를 사용하는 편이 낫다.

## 14.4 동기화 클래스의 내부 구조

ReentrantLock이나 Semaphore 클래스 뿐만 아니라 CountDownLatch, ReentrantReadWriteLock, SynchronousQueue, FutureTask 등의 클래스는 `AbstractQueuedSynchronizer(AQA)`를 상속받아 구현돼 있다.

## 14.5 AbstractQueuedSynchronizer

### 14.5.1 간단한 래치

## 14.6 java.util.concurrent 패키지의 동기화 클래스에서 AQS 활용 모습

### 14.6.1 ReentrantLock

### 14.6.2 Semaphore와 CountDownLatch

### 14.6.3 FutureTask

### 14.6.4 ReentrantReadWriteLock

## 요약
