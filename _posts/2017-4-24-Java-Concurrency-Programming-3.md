---
layout: post
title: 자바 병렬 프로그래밍 3장 객체 공유
---

# 3장 객체 공유

여러 개의 스레드에서 특정 객체를 동시에 사용하려 할 때 섞이지 않고 안전하게 동작하도록 객체를 공유하고 공개하는 방법을 살펴본다.

## 3.1 가시성

* 재배치(reordering)
재배치 형상은 특정 메소드의 소스코드가 100% 코딩된 순서로 동작한다는 점을 보장할 수 없다는 점에 기인하는 문제이며, 단일 스레드로 동작할 때는 차이점을 전혀 알아챌 수 없지만 여러 스레드가 동시에 동작하는 경우에는 확연하게 나타날 수 있다.
`실제로는 JVM이 최신 컴퓨터 하드웨어가 제공하는 기능을 100% 활용할 수 있게 의도적으로 설계한 부분이다.`

```
동기화 기능을 지정하지 않으면 컴파일러나 프로세서, JVM(자바 가상 머신) 등이 프로그램 코드가 실행되는 순서를 임의로 바꿔 실행하는 이상한 경우가 발생하기도 한다. 다시 말하자면, 동기화 되지 않은 상황에서 메모리상의 변수를 대상으로 작성해둔 코드가 '반드시 이런 순서로 동작할 것이다'라고 단정지을 수 없다.
```

### 3.1.1 스테일 데이터
```
컴퓨터 처리에서, 만약 한 프로세서가 피연산자의 값을 변경하고, 그리고 이어서 그 피연산자를 불러왔을 때 피연산자의 새로운 값이 아닌 변경되기 이전의 값을 가지고 왔다면, 이때 그것을 스테일 데이터라고 부른다.
```

### 3.1.2 단일하지 않은 64비트 연산

* 64비트를 사용하는 숫자형(double 이나 long 등)에 volatile 키워드를 사용하지 않은 경우에는 난데없는 갑마저 생길 가능성이 있다.
* 자바 메모리 모델은 메모리에서 값을 가져오고(fetch) 저장(store)하는 연산이 단일해야 한다고 정의하고 있지만, volatile로 지정되지 않은 long이나 double 형의 `64비트 값에 대해서는 메모리에 쓰거나 읽을 때 두 번의 32비트 연산을 사용할 수 있도록 허용`하고 있다.

### 3.1.3 락과 가시성

```
락은 상호 배제(mutual exclusion) 뿐만 아니라 정상적인 메모리 가시성을 확보하기 위해서도 사용한다. 변경 가능하면서 여러 스레드가 공유해 사용하는 변수를 각 스레드에서 각자 최신의 정상적인 값으로 활용하려면 동일한 락을 사용해 모두 동기화시켜야 한다.
```

### 3.1.4 volatile 변수

* volatile로 선언된 변수의 값을 바꿨을 때 다른 스레드에서 항상 최신 값을 읽어갈 수 있도록 해준다.
* 컴파일러와 런타임 모두 `이 변수는 공유해 사용하고, 따라서 실행 순서를 재배치해서는 안 된다`고 이해한다.
* 프로세서의 레지스터에 캐시되지도 않고, 프로세서 외부의 캐시에도 들어가지 않기 때문에 volatile 변수의 값을 읽으면 항상 다른 스레드가 보관해둔 최신의 값을 읽어갈 수 있다.

```
락을 사용하면 가시성과 연산의 단일성을 모두 보장받을 수 있다. 하지만 volatile 변수는 연산의 단일성은 보장하지 못하고 가시성만 보장한다.
```

#### volatile 변수는 다음과 같은 상황에서만 사용하는 것이 좋다.
* 변수에 값을 저장하는 작업이 해당 변수의 현재 값과 관련이 없거나 해당 변수의 값을 변경하는 스레드가 하나만 존재
* 해당 변수가 객체의 불변조건을 이루는 다른 변수와 달리 불변조건에 관련되어 있지 않다.
* 해당 변수를 사용하는 동안에는 어떤 경우라도 락을 걸어 둘 필요가 없는 경우

## 3.2 공개와 유출

### 3.2.1 생성 메소드 안정성

* 생성 메소드가 실행되는 도중에 해당 객체를 외부에 공개한다면 정상적이지 않은 상태의 객체를 외부에서 불러 사용할 가능성 있다.
* 스레드를 생성과 동시에 '시작' 시키는 건 문제의 소지가 많은 일이다. 스레드를 생성하면서 바로 시작시키기보다는 스레드를 시작시키는 기능을 start 나 initialize 등의 메소드로 만들어 사용하는 편이 좋다.
* 생성 메소드에서 오버라이드 가능한 다른 메소드를 호출하는 경우가 있다면 this 참조가 외부에 유출될 가능성이 있다.

## 3.3 스레드 한정

### 3.3.1 스레드 한정 - 주먹구구식

### 3.3.2 스택 한정

* 로컬 변수는 모두 암묵적으로 현재 실행 중인 스레드에 한정되어 있다고 볼 수 있다. 즉 로컬 변수는 현재 실행 중인 스레드 내부의 스택에만 존재하기 때문이며, 스레드 내부의 스택은 외부 스레드에서 물론 볼 수 없다. 

### 3.3.3 ThreadLocal

[ThreadLocal 사용법](http://javacan.tistory.com/entry/ThreadLocalUsage)

## 3.4 불변성

다음 조건을 만족하면 해당 객체는 불변 객체이다.
* 생성되고 난 이후에는 객체의 상태를 변경할 수 없다.
* 내부의 모든 변수는 final로 설정돼야 한다.
* 적절한 방법으로 생성되야 한다. (예를 들어 this 변수에 대한 참조가 외부로 유출되지 않아야 한다.)

### 3.4.1 final 변수

* C++의 const 키워드보다 훨씬 강화된 기능을 갖고 있는 final 키워드는 불변 객체를 생성할 때도 도움을 준다. final을 지정한 변수의 값은 변경할 수 없는데 자바 메모리 모델을 놓고 보면 약간 특별한 의미를 찾을 수 있다.
* final 키워드를 적절하게 사용하면 초기화 안정성을 보장하기 때문에 별다른 동기화 작업 없이도 불변 객체를 자유롭게 사용하고 공유할 수 있다.

### 3.4.2 예제: 불변 객체를 공개할 때 volatile 키워드 사용

## 3.5 안전 공개

### 3.5.1 적절하지 않은 공개 방법: 정상적인 객체도 문제를 일으킨다.

### 3.5.2 불변 객체와 초기화 안정성

### 3.5.3 안전한 공개 방법의 특성

### 3.5.4 결과적으로 불변인 객체

### 3.5.5 가변 객체

### 3.5.6 객체를 안전하게 공유하기

---


> 참고
> [병렬 프로그램을 위한 어노테이션](http://aroundck.tistory.com/3423)
