# 4장 객체 구성

## 4.1 스레드 안전한 클래스 설계

객체 내부의 여러 변수가 갖고 있는 현재 상태를 사용하고자 할 때 값이 계속해서 변하는 상황에서도 값을 안전하게 사용할 수 있도록 조절하는 방법을 동기화 정책이라고 한다.

### 4.1.1 동기화 요구사항 정리

### 4.1.2 상태 의존 연산

#### 상태 의존 연산
* 현재 조건에 따라 동작 여부가 결정되는 연산을 상태 의존 (state-dependency) 연산이라고 한다.
* 예를 들어 아무것도 들어있지 않은 큐에서는 값을 뽑아 낼 수 가 없다.

#### wait 과 notify
* wait 과 notify를 사용하면 특정 상태가 원하는 조건에 다다를 때까지 효율적으로 기다릴 수 있다.


### 4.1.3 상태 소유권

* C++ 언어에서 특정 메소드에 객체 인스턴스를 넘겨주는 상황을 생각해보면, 호출하는 메소드에 객체와 함께 객체에 대한 소유권도 함께 넘겨주는 것인지, 잠시만 사용하도록 빌려주는 형식인지, 아니면 메소드 인자로 넘겨주지만 계속해서 함께 사용하는 모양인지를 명확하게 정의할 수 있다.
* 대부분의 경우 소유권과 캡슐화 정책은 함께 고려하는 경우가 많다.
* 클래스는 일반 메소드나 생성 메소드로 넘겨받는 객체에 대한 소유권을 갖지 않는다는게 일반적인 모양이지만, 넘겨받은 객체의 소유권을 확보하도록 메소드를 특별하게 작성하면 소유권을 확보할 수도 있다.

## 4.2 인스턴스 한정

* 객체를 적절하게 캡슐화하는 것으로도 스레드 안전성을 확보할 수 있는데, 이런 경우 흔히 '한정'이라고 단순하게 부르기도 하는 '인스턴스 한정' 기법을 활용하는 셈이다.

```
- 특정 클래스 인스턴스에 한정 (private 변수)
- 문법적으로 블록 내부에 한정 (블록 내부의 로컬 변수)
- 특정 스레드에 한정
```

* 기본적인 컬렉션 클래스인 ArrayList 나 HashMap 같은 클래스는 스레드에 안전하지 않지만, 자바 플랫폼 라이브러리에는 이런 클래스를 머티스레드 환경에서 안전하게 사용할 수 있도록 도와주는 Collections.synchronizedList와 같은 팩토리 메소드가 만들어져 있다.
* 이런 팩토리 메소드는 컬렉션의 기본 클래스에 스레드 안전성을 확보하는 방법으로 대부분 데코레이터 패터을 활용하며, 이런 팩토리 메소드의 결과로 만들어진 래퍼 클래스는 기본 클래스의 메소드를 호출하는 연동 역할만 하면서 그와 동시에 모든 메소드가 동기화되어 있다.
* 즉, `래퍼 클래스를 거쳐야만 원래 컬렉션 클래스의 내용을 사용`할 수 있기 때문에 래퍼 클래스는 스레드 안전성을 확보할 수 있다.
(다시 말하자면 원래 컬렉션 객체가 새로운 래퍼 객체 내부에 제한된 상태)

### 4.2.1 자바 모니터 패턴

Monitor를 획득?? 그래서 모니터 패턴??

### 4.2.2 예제: 차량 위치 추적

## 4.3 스레드 안전성 위임

### 4.3.1 예제: 위임 기법을 활용한 차량 추적

웹 애플리케이션 기동 시 properties에 있는 설정 정보들을 컬렉션 객체에 저장하고 이를 가져다가 쓰는 경우가 많은데 이 객체에 변경을 막는 제약 조건을 걸고 싶을 때가 있다.
즉, read-only 한 객체를 만들고 싶은 경우인데 이럴 때 다음의 메소드를 사용하면 좋을 것 같다.

* Collections.unmodifiableMap
* Collections.unmodifiableList

해당 메소드는 파라미터로 전달 받은 컬렉션 객체에 어떠한 변경이라도 발생하면 예외를 return한다.

> [Collections.unmodifiableMap 메소드를 이용한 read-only 객체 만들기](http://lng1982.tistory.com/155)

### 4.3.2 독립 상태 변수

### 4.3.3. 위임할 때의 문제점

* 클래스가 서로 의존성 없이 독립적이고 스레드 안전한 두 개 이상의 클래스를 조합해 만들어져 있고 두 개 이상의 클래스를 한번에 처리하는 복합 연산 메소드가 없는 상태라면, 스레드 안전성을 내부 변수에게 모두 위임할 수 있다.

### 4.3.4 내부 상태 변수를 외부에 공개

* 상태 변수가 스레드 안전하고, 클래스 내부에서 상태 변수의 값에 대한 의존성을 갖고 있지 않고, 상태 변수에 대한 어떤 연산을 수행하더라도 잘못된 상태에 이를 가능성이 없다면, 해당 변수는 외부에 공개해도 안전하다.

### 4.3.5 예제: 차량 추적 프로그램의 상태를 외부에 공개

## 4.4 스레드 안전하게 구현된 클래스에 기능 추가

### 4.4.1 호출하는 측의 동기화

* 제 3의 도우미 클래스를 만들어 사용하려는 방법을 올바르게 구현하려면 클라이언트 측 락 (client-side lock) 이나 외부 락 (external lock)을 사용해 List 가 사용하는 것과 동일한 락을 사용해야 한다.
* 특정 클래스 내부에서 사용하는 락을 전혀 관계없는 제 3의 클래스에서 갖다 쓰기 때문에 훨씬 위험해 보이는 방법이다.
* 락이나 동기화 전략에 대한 내용을 정확하게 구현하고 공지하지 않은 클래스를 대상으로 클라이언트 측 락을 적용하려면 충분히 주의를 기울여야 한다.

### 4.4.2 클래스 재구성 (composition)

## 4.5 동기화 정책 문서화하기

* 개발한 클래스에 단일 연산을 추가하고자 한다면 어떤 락으로 동기화해야 안전하게 구현할 수 있는지에 대해서 문서로 알려줘야 한다.
* 내부적으로 사용하는 특정 상태 변수를 락으로 동기화시켰다면 유지보수 인력이 알아볼 수 있도록 적어둬야 한다.
* 자바 5부터 사용할 수 있는 @GuardedBy 등의 어노테이션만 활용해도 훌륭하다.

### 4.5.1 애매한 문서 읽어내기
