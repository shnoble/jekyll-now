---
layout: post
title: 자바 병렬 프로그래밍 10장 활동성을 최대로 높이기
---
# 10장 활동성을 최대로 높이기

## 10.1 데드락

데드락은 예전부터 '식사하는 철학지' 문제로 널리 알려져 왔다.
지향 그래프(directed graph)를 예로 들어보면, 그래프의 노드는 스레드 하나를 의미하고, 그래프의 에지(edge)는 '스레드 B가 확보한 독점 자원을 스레드 A가 가져가려고 대기하는 상태'를 나타낸다.

* 데이터베이스 시스템
데이터베이스 서버가 트랜잭션 간에 데드락이 발생했다는 사실을 확인하고 나면(대기 상태를 나타내는 그래프에서 사이클이 발생하는지를 확인하는 방법), 데드락이 걸린 트랜잭션 가운데 희생양을 하나 선택해 해당 트랜잭션을 강제 종료시킨다.
만약, 트랜잭션을 요청했던 애플리케이션에서 중단된 트랜잭션을 재시도하도록 돼 있었다면, 재시도한 트랜잭션은 데드락이 걸릴 수 있는 상대방 트랜잭션이 모두 끝난 상태이기 때문에 문제 없이 결과를 얻을 수 있게 된다.

### 10.1.1 락 순서에 의한 데드락

`프로그램 내부의 모든 스레드에서 필요한 락을 모두 같은 순서로만 사용한다면, 락 순서에 의한 데드락은 발생하지 않는다.`

### 10.1.2. 동적인 락 순서에 의한 데드락

락을 확보하려는 순서를 내부적으로 제어할 수 없기 때문에 데드락을 방지하려면 락을 특정 순서에 맞춰 확보하도록 해야하고, 락을 확보하는 순서를 프로그램 전반적으로 동일하게 적용해야 한다.

객체 순서를 부여할 수 있는 방법 중 하나는 바로 System.identifyHashCode를 사용하는 방법이다.

계좌이체 코드의 경우 Account 클래스 내부에 계좌 번호와 같이 유일하면서 불변이고 비교도 가능한 값을 키로 갖고 있다면 한결 쉬운 방법으로 락 순서를 지정할 수 있다.

### 10.1.3 객체 간의 데드락

락을 확보한 상태에서 에일리언 메소드를 호출한다면 가용성에 문제가 생길 수 있다. 에일리언 메소드 내부에서 다른 락을 확보하려고 하거나, 아니면 예상하지 못한 만큼 오랜 시간 동안 계속해서 실행된다면 호출하기 전에 확보했던 락이 필요한 다른 스레드가 계속해서 대기해야 하는 경우도 생길 수 있다.

### 10.1.4 오픈 호출

호출한 메소드 내부에서 어떤 일이 일어나는 지 알지 못하기 때문에 특정 락을 확보한 상태에서 에일리언 메소드를 호출한다는 건 파급 효과를 분석하기가 굉장히 어렵고, 따라서 위험도가 높은 일이다.

락을 전혀 확보하지 않은 상태에서 메소드를 호출하는 것을 오푼 호출(open call)이라고 하며, 메소드를 호출하는 부분이 모두 오픈 호출로만 이뤄진 클래스는 락을 확보한 채로 메소드를 호출하는 클래스보다 훨씬 안정적이며 다른 곳에서 불러다 쓰기도 좋다.

`꼭 필요한 최소한의 부분에만 synchronized 블록을 사용하면 확장성에서도 이득을 볼 수 있다.`


### 10.1.5 리소스 데드락

자원 풀은 풀이 비어 있을 때 풀 내부의 자원을 달라고 요청하는 객체가 대기하도록 만들기 위해 일반적으로 세마포어를 사용해 구현하는 경우가 많다.

자원과 관련해 발생할 수 있는 또 다른 데드락 상황은 `스레드 부족 데드락(thread-starvation deadlock)`이다.
단일 스레드로 동작하는 Executor에서 현재 실행 중인 작업이 또 다른 작업을 큐에 쌓고는 그 작업이 끝날 때까지 대기하는 데드락 상화이다.


## 10.2 데드락 방지 및 원인 추적

두 단계의 전략으로 데드락 발생 가능성이 없는지 확인
* 1 단계: 여러 개의 락을 확보해야 하는 부분이 어디인지를 찾아내는 단계
* 2 단계: 이와 같은 부분에 대한 전반적인 분석 작업을 진행해 프로그램 어디에서건 락을 지정된 순서에 맞춰 사용하도록 해야 한다.

가능한 부분에서는 최대한 오플 호출 방법을 사용하면 분석과 확인 작업이 조금 간편해 진수 있다.

### 10.2.1 락의 시간 제한

Lock 클래스의 메소드 가운데 시간을 제한할 수 있는 `tryLock 메소드`를 사용하는 방법

### 10.2.2 스레드 덤프를 활용한 데드락 분석

JVM이 만들어 내는 스레드 덤프(thread dump)를 활용해 데드락이 발생한 위치를 확인하는 데 도움을 얻을 수 있다.

* 스레드 덤프
    * 실행 중인 모든 스레드의 스택 트레이스(stack trace)가 담겨 있다.
    * 락과 관련된 정보, 각 스레드 마다 어떤 락을 확보하고 있는지, 스택의 어느 부분에서 락을 확보했는지 그리고 대기 중인 스레드가 어느 락을 확보하려고 대기 중이었는지 등에 대한 정보
    * JVM은 스레드 덤프를 생성하기 전에 ㄹ락 대기 상태 그래프에서 사이클이 발생했는지, 즉 데드락이 발생한 부분이 있는지 확인한다.
    * 만약, 데드락이 발생했다고 판단되면 어느 락과 어느 스레드가 데드락에 관여하고 있는지, 프로그램 내부의 어느 부분에서 락 확보 규칙을 깨고 있는지에 대한 정보도 스레드 덤프에 포함된다.

`자바 5.0에서는 명시적인 Lock에 대한 기록은 스레드 덤프에 포함되지 않는다` 

자바 6에서는 명시적인 Lock을 사용해도 스레드 덤프에 포함되며 데드락을 검출할 때 명시적인 락을 포함하는 데드락도 검출해준다.
하지만 락을 어디에서 확보했는지에 대해 출력되는 정보는 `암묵적인 락에 대한 내용만큼 정확하지는 않다.`
암묵적인 락은 락을 확보하는 시점의 스택 프레임에 연결돼 있지만, 명시적인 락은 락을 확보한 스레드와 연결돼 있기 때문이다.

## 10.3 그 밖의 활동성 문제점

병렬 프로그램을 작성하다 보면 소모(starvation), 놓친 신호, 라이브락(livelock) 등과 같이 다양한 원인을 마주치게 된다.

### 10.3.1 소모

소모(starvation) 상태는 스레드가 작업을 진행하는데 꼭 필요한 자원을 영영 할당받지 못하는 경우에 발생한다.
소모 상태를 일으키는 가장 흔한 원인은 바로 CPU이다.
`자바 애플리케이션에서 소모 상황이 발생하는 원인은 대부분 스레드의 우선순위를 적절치 못하게 올리거나 내리는 부분에 있다.`
또한 락을 확보한 채로 종료되지 않는 코드를 실행할 때, 다른 스레드에서 해당 락을 가져갈 수 없기 때문에 소모 상황이 발생한다.

일반적인 상황에서는 스레드 우선 순위를 변경하지 않고 그래도 사용하는 방법이 가장 현명하다고 할 수 있다.

### 10.3.2 형편 없는 응답성

소모 상황보다 약간 나은 경우는 바로 응답성이 떨어지는 상황이다.
응답성이 떨어지는 경우는 백그라운드 스레드를 사용하는 GUI 애플리케이션에서 굉장히 일상적이다.

### 10.3.3 라이브락

라이브락(livelock)도 일종의 활동성 문제 가운데 하나이다.
대기 중인 상태가 아니었다해도 특정 작업의 결과를 받아와야 다음 단계로 넘어갈 수 있는 작업이 실패할 수밖에 없는 기능을 곗혹해서 재시도하는 경우에 쉽게 찾아볼 수 있다.

## 요약

활동성과 관련된 가장 흔한 형태는 바로 락 순서에 의한 `데드락`이다.
애플리케이션 내부의 스레드에서 두 개 이상의 락을 한꺼번에 사용해야 하는 부분이 있다면, 항상 일정한 순서를 두고 여러 개의 락을 확보해야만 한다.
`가장 효과적인 해결 방법은 항상 오픈 호출 방법을 사용해 메소드를 호출하는 것이다.`
